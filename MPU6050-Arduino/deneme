#include <Wire.h>
#include "KalmanFilter.h"
#include "Transformation.h"
#include "Integration.h"

#define RESTRICT_PITCH

////////////////////// I2C I/0 Methods ///////////////////////////////////////

// TODO: examine globals
const uint8_t IMUAddress = 0x68; // AD0; logic low on the PCB
const uint16_t I2C_TIMEOUT = 1000; // error checking in I2C communication

uint8_t i2cWrite(uint8_t registerAddress, uint8_t data, bool sendStop){
  return i2cWrite(registerAddress, &data, 1, sendStop);
}

uint8_t i2cWrite(uint8_t registerAddress, uint8_t* data, uint8_t length, bool sendStop){
  Wire.beginTransmission(IMUAddress);
  Wire.write(registerAddress);
  Wire.write(data, length);
  uint8_t fail = Wire.endTransmission(sendStop);
  if (fail){
    Serial.print(F("i2cWrite failed: "));
    switch (fail){
      case 1:
        Serial.println("Data too long to fit in transmit buffer.");
        break;
      case 2:
        Serial.println("Received NACK on transmit of address.");
        break;
      case 3:
        Serial.println("Received NACK on transmit of data.");
        break;
      case 4:
        Serial.println("Other");
        break;
      case 5:
        Serial.println("Timeout");
        break;
    }
  }
  return fail;
}

uint8_t i2cRead(uint8_t registerAddress, uint8_t* data, uint8_t nbytes){
  uint32_t timeoutTimer;
  Wire.beginTransmission(IMUAddress);
  Wire.write(registerAddress);
  uint8_t fail = Wire.endTransmission(false); // hold the bus
  if (fail){
    Serial.print(F("i2cWrite failed: "));
    switch (fail){
      case 1:
        Serial.println("Data too long to fit in transmit buffer.");
        break;
      case 2:
        Serial.println("Received NACK on transmit of address.");
        break;
      case 3:
        Serial.println("Received NACK on transmit of data.");
        break;
      case 4:
        Serial.println("Other");
        break;
      case 5:
        Serial.println("Timeout");
        break;
    }
    return fail;
  }
  Wire.requestFrom(IMUAddress, nbytes, (uint8_t)true); // release the bus after reading
  for (uint8_t i = 0; i < nbytes; i++){
    if (Wire.available()){
      data[i] = Wire.read();
    }
    else{
      timeoutTimer = micros();
      while(((micros() - timeoutTimer) < I2C_TIMEOUT) && !Wire.available());
      if (Wire.available()){
        data[i] = Wire.read();
      }
      else{
        Serial.println(F("i2cRead timeout."));
        return 5;
      }
    }
  }
  return 0;
}

///////////////////////////////////////////////////////////////////////////

KalmanFilter kalmanX, kalmanY, kalmanZ;
Transformation trans;
Integration integrateX, integrateY; // hmms

// MPU6050 data
double accX, accY, accZ;
double gyroX, gyroY, gyroZ;
int16_t tempRaw;

double gyroXangle, gyroYangle, gyroZangle; // raw angle of gyro
// double compAngleX, compAngleY; // complementary filter
double kalAngleX, kalAngleY, kalAngleZ; // angle calculated using the Kalman filter

uint32_t timer;
uint8_t i2cData[14]; // I2C buffer

void setup() {
  Serial.begin(115200);
  Wire.begin();
#if ARDUINO >= 157 // ?? 
  Wire.setClock(400000UL); // I2c frequency <- 400 kHz // why two separate definitions? // UL?
#else
  TWBR = ((F_CPU / 400000UL) - 16) / 2; // I2c frequency <- 400 kHz
#endif

  i2cData[0] = 7; // sample rate <- 1000 Hz
  i2cData[1] = 0x00;
  i2cData[2] = 0x00; // gyro range <- +-250 deg/s
  i2cData[3] = 0x00; // accelerometer range <- +- 2 g
  while (i2cWrite(0x19, i2cData, 4, false)); // simultaneous write to all four registers
  while (i2cWrite(0x6B, 0x01, true));
  
  while (i2cRead(0x75, i2cData, 1));
  if (i2cRead[0] != 0x68){ // read self register
    Serial.print(F("Cannot read the sensor."));
    while (1);
  }
  
  delay(1000); // sensor stabilization
  
  // setting Kalman & gyro starting angles
  while (i2cRead(0x3B, i2cData, 6));
  accX = (i2cData[0] << 8 | i2cData[1];
  accY = (i2cData[2] << 8 | i2cData[3];
  accZ = (i2cData[4] << 8 | i2cData[5];
  
  
  // equations from online datasheet
#ifdef RESTRICT_PITCH
  double roll = atan2(accY, accZ) * RAD_TO_DEG;
  double pitch = atan (-accX / sqrt(accY * accY + accZ * accZ)) * RAD_TO_DEG;
#else
  double roll = atan(accY / sqrt(accX * accX + accZ * accZ)) * RAD_TO_DEG;
  double pitch = atan2(-accX, accZ) * RAD_TO_DEG;
#endif

  // set starting angle
  kalmanX.setStartingAngle(roll);
  kalmanY.setStartingAngle(pitch);
  gyroXangle = roll;
  gyroYangle = pitch;
  compAngleX = roll;
  compAngleY = pitch;
  
  timer = micros();
}

void loop(){
  // update values on new cycle
  while (i2cRead(0x3B, i2cData, 14));
  accX = (i2cData[0] << 8) | i2cData[1];
  accY = (i2cData[2] << 8) | i2cData[3];
  accZ = (i2cData[4] << 8) | i2cData[5];
  tempRaw = (i2cData[6] << 8) | i2cData[7];
  gyroX = (i2cData[8] << 8) | i2cData[9];
  gyroY = (i2cData[10] << 8) | i2cData[11];
  gyroZ = (i2cData[12] << 8) | i2cData[13];
  
  double dt = (double)(micros() - timer) / 1000000;
  timer = micros();
  
  // equations from online datasheet
#ifdef RESTRICT_PITCH
  double roll = atan2(accY, accZ) * RAD_TO_DEG;
  double pitch = atan(-accX / sqrt(accY * accY + accZ * accZ)) * RAD_TO_DEG;
#else
  double roll = atan(accY / sqrt(accX * accX + accZ * accX)) * RAD_T0_DEG;
  double pitch = atan2(-accX, accZ) * RAD_TO_DEG;
#endif

  // convert to deg/s
  double gyroXrate = gyroX / 131.0;
  double gyroYrate = gyroY / 131.0;
  double gyroZrate = gyroZ / 131.0;    
  
#ifdef RESTRICT_PITCH
  // fix accelerometer angle jumps between +-180 deg
  if ((roll < -90 && kalAngleX > 90) || (roll > 90 && kalAngleX < -90)){
    kalmanX.setStartingAngle(roll);
    compAngleX = roll;
    kalAngleX = roll;
    gyroXangle = roll;
  }
  else
    kalAngleX = kalmanX.getAngle(roll, gyroXrate, dt);
  
  if (abs(kalAngleX) > 90)
    gyroYrate = -gyroYrate; // fit restricted accelerometer reading
  kalAngleY = kalmanY.getAngle(pitch, gyroYrate, dt);
#else
  // fix acceleroeter angle jumps between +-180 deg
  if ((pitch < -90 && kalAngleY > 90) || (pitch > 90 && kalAngleY < -90)){
    kalmanY.setStartingAngle(pitch);
//  compAngleY = pitch;
    kalAngleY = pitch;
    gyroYangle = pitch;
  }
  else{
    kalAngleY = kalmanY.getAngle(pitch, gyroYrate, dt);
  }
  
  if (abs(kalAngleY) > 90){
    gyroXrate = -gyroXrate; // fit restricted accelerometer reading
  }
  kalAngleX = kalmanX.getAngle(roll, gyroXrate, dt);
#endif

// transform filtered accel to normal coordinates
  double* absoluteAcceleration = transformToNormal(


//gyro with no filter
//  gyroXangle += kalmanX.getRate() * dt;
//  gyroYangle += kalmanY.getRate() * dt;

  // gyro with complemetnary filter
//   compAngleX = 0.93 * (compAngleX + gyroXrate * dt) + 0.07 * roll;
//  compAngleY = 0.93 * (compAngleY + gyroYrate * dt) + 0.07 * pitch;

  // gyro with unbiased rate
  gyroXangle += kalmanX.getRate() * dt;
  gyroYangle += kalmanY.getRate() * dt;
  gyroZangle += kalmanZ.getRate() * dt;
  
  // reset gyro drifts
  if (gyroXangle < -180 || gyroXangle > 180){
    gyroXangle = kalAngleX;
  }
  if (gyroYangle < -180 || gyroYangle > 180){
    gyroYangle = kalAngleY;
  }
  if (gyroZangle < -180 || gyroZangle > 180){
    gyroYangle = kalAngleZ;
  }
    
    
    /////
// integrate gyro deg/s to get angles
  double angleX = integrate(gyroXangle   );
  double angleY = integrate(gyroYangle   );
    
    /////
    
  // monitor    
#if 1
  Serial.print(accX); Serial.print("\t");
  Serial.print(accY); Serial.print("\t");
  Serial.print(accZ); Serial.print("\t");
  
  Serial.print(gyroX); Serial.print("\t");
  Serial.print(gyroY); Serial.print("\t");
  Serial.print(gyroZ); Serial.print("\t");
  
  Serial.print("\t");
#endif

  Serial.print(roll); Serial.print("\t");
  Serial.print(gyroXangle); Serial.print("\t");
  Serial.print(compAngleX); Serial.print("\t");
  Serial.print(kalAngleX); Serial.print("\t");
  
  Serial.print("\t");
  
  Serial.print(pitch); Serial.print("\t");
  Serial.print(gyroYangle); Serial.print("\t");
  Serial.print(compAngleY); Serial.print("\t");
  Serial.print(kalAngleY); Serial.print("\t");
  
  Serial.print("\r\n");
  delay(2);
}
